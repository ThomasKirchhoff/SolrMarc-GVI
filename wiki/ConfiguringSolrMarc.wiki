#summary This page will guide you through configuring and using SolrMarc
<wiki:toc max_depth="5" />

=== About This Guide ===

This configuring SolrMarc guide explains the setup of the two configuration files that control the operation of SolrMarc and gives examples of custom indexing routines.

<br />

=== About !SolrMarc ===

A Configurable Java-based program for indexing MARC records into a Solr index.

The SolrMarc program reads in MARC records stored in standard binary format (ISO 2709) and uses a configurable and customizable script for extracting values from the fields and sub-fields of the MARC record to build an index entry for adding to Solr.  Additionally, so that it can run faster, rather than building the records and POSTing them to a Solr search engine, this program directly writes to the index directory of the Solr search engine.

<br />

=== config.properties File ===

The main configuration of the program is currently done via a properties file that is created and stored in the jar file produced by the build process. The name of this file can be passed in as the first parameter on the command line, however if only one config.properties file is stored in the jar file, that one will be used by default.  An example config.properties file is below:

{{{
# Properties for the Java import program

# Path to your solr instance
solr.path = C:/Development/blacklight-0.2/solr-home
solr.indexer.properties = blacklight.properties
solr.indexer = BlacklightIndexer

#optional URL of running solr search engine to cause updates to be recognized.
solr.hosturl = http://localhost:8983/solr/update

marc.to_utf_8 = true
marc.permissive = true
marc.default_encoding = MARC8
marc.include_errors = true
}}}

<br />

==== config.properties File Entries ====

 * *solr.path:* lists the full path to the Solr home directory, which should contain the directories {{{etc}}}, {{{conf}}} and {{{data}}}.  The directory {{{conf}}} should contain a file named _schema.xml_ which describes the different indexing fields that the instance of the Solr search engine is expecting, and the data directory is where the Solr index files will be placed.

 * *solr.indexer.properties:* lists the name of the properties file that defines the mapping from the MARC record fields and sub-fields to the Solr index entries. For details of how this mapping is done, please see below.

 * *solr.indexer:* (optional); specifies the name of a custom indexing class which defines any custom routines for extracting and mapping data for a particular Solr index field. These custom routines will only be needed in cases where values from several different MARC fields and sub-fields need to be consulted to determine the value to add to the Solr index field. Several examples of these custom indexing routines are given below. If, however, you can handle all of the necessary MARC field-to-Solr index field mappings using the available specification language, you do not need to define a value for this entry, and the default SolrIndexer class will be used.

 * *solr.hosturl:* (optional); specifies the URL of a currently running Solr search engine that is referencing the same index data that is specified in the {{{solr.path}}}, entry.  If this value is given, when the indexing process completes, this indexing program will send a signal to the currently running Solr search engine, which will cause it to read the newly modified index files. This is purely a convenience function, to avoid having to stop and restart the running Solr search engine. If no search engine is running at the URL specified, the program will quietly proceed along it way, with the understanding that when that search engine is eventually restarted it will read in the new index data anyway.

 * *marc.to_utf_8:* a boolean value, defaulting to false.  If it is set to true, then as MARC records are read in the program translate the fields of the record to UTF-8, prior to sending the record to the indexer.  If the records are determined to already be encoded in UTF-8 the field values will be unchanged.   

  <b>Note:</b>  You are strongly recommended to use this setting to translate your records to UTF-8, any of the other character encodings that are commonly used in MARC records likely to cause display problems for special characters that occur in the data.

 * *marc.permissive:* a boolean value, defaulting to false.  If it is set to true, then as MARC records are read in if the program encounters ill-formed records, it will make an attempt to work around the problem and read in and index the record rather than simply skipping over the bad record.  Note that the feature does not and cannot fix records that have a valid MARC record structure, but only which have incorrect or invalid data entered in some fields. 

 * *marc.default_encoding:* valid values:  {{{MARC8}}}, {{{UTF8}}}, {{{UNIMARC}}}, {{{ISO8859_1}}}, or {{{BESTGUESS}}}.  It is used to specify what encoding is used in the marc records that you will be importing.  In all likelihood your data will be in one of the first two listed above, or maybe in the third if you are a European institution.  If you have no idea what encoding your original data is in, you can specify {{{BESTGUESS}}} and the program will do its best to correctly determine what encoding is used.  Note also if you provide an incorrect value for this entry, _and_ if you set the entry {{{marc.permissive}}} to true, the MARC record reader will try to detect when you are wrong, and do its best to recover from the problem.

 * *marc.include_errors:* a boolean value, defaulting to false.  If it is set, _and_ if {{{marc.permissive}}} is also set to true, then any errors that are encountered in the process of reading a MARC record, will be stored in the solr index record that is produced, this will allow catalogers to review the errors encountered during reading and to correct the original records in which the errors occurred.

<br />

==== Special Purpose config.properties File Entries ====

Lastly, there are several special purpose entries that will not be used in general, and usually won’t appear in the config.properties file.

 * *marc.override:* lists the class name of the implementation of the MarcFactory object to use to override the default one provided in the {{{marc4j}}} library.  You almost certainly will not need to use this entry.  It is needed at UVa since the MARC records that we are working from have multiple 001 fields (which actually makes them invalid MARC records) and rather than simply keeping the last of these 001 fields that occurs (and discarding the rest), we need to specifically select the correct 001 field to use in the indexing process.

 * *solr.optimize_at_end:* a boolean value, defaulting to false. If it is set to true, when the program has finished indexing all of the MARC records provided to it, it will optimize the index, which will make searches perform much faster.  This entry is set by the shell script {{{optimizesolr}}}, which is found in the dist directory.

 * *marc.ids_to_delete:* supplies the name of a file that contains a list of Solr item ids, one per line, that are to be removed from the Solr index.

 * *marc.delete_record_id_mapper:* used in conjunction with {{{marc.ids_to_delete}}} when the entries that occur in the {{{marc.ids_to_delete}}} file need to be processed to correspond to the actual ids that occur in the solr index. For instance at UVa the records have ids like _u184783_ but the entry that would appear in the {{{marc.ids_to_delete}}} file produced by our system would be merely 184783.

 * *marc.verbose:* a boolean value. If it is set to true, instructs the program to print out the entire MARC record as it is read in, followed by the entire index record that will be sent to Solr.

 * *marc.include_if_present* and *marc.include_if_missing:* used for reprocessing records that have already been indexed, if a new index field is added.  They are only useful when the newly added field draws its information from fields that only occur in a small subset of records. For example, in the Indexer configuration file shown below, the following field specification:
 
   {{{instrument_facet = 048m[0-1], instrument_map}}}

 specifies that the information should be found in the 048m field of the MARC record. This was a typo, it should have read 048a, therefore no index records were created with a value for {{{instrument_facet}}}.  To fix it, rather than re-index all of our records, I was able to set {{{marc.include_if_present = 048a}}}  which specifies that only those records that have one or more 048a fields will be re-indexed, the rest will be skipped (which is fine since the indexed record would be the same in any case.)  Rather than setting these entries, you should use the {{{filterrecords}}} script which internally uses these settings to operate as a marc-based-grep program.

<br />

===The Index Configuration Properties File ===

The specification of which MARC fields and sub-fields are to be mapped to which Solr index fields is handled via the index configuration properties file, the name of which is specified in the {{{solr.indexer.properties}}} entry in the main properties file as described above. Since this configuration file is a properties file, there are certain constraints of how the file is structured. Basically all properties files consist of a number of pairs of values separated by an equals sign. The key values represent the name of the field that will be added to the Solr index record. All of these must either match a field definition that occurs in the _schema.xml_ file for the Solr search engine, or they must match a dynamicField definition in that file.   If any index entries are listed here that do not match either a field definition or a dynamicField definition from the _schema.xml_ file, the indexing will fail.

 {{{
 id = 001, first
author_text = 100a:110a:111a:130a
author_display = 100a:110a
published_text = 260a
material_type_text = 300a
notes_text = 500a:505a
uniform_title_text = 240a:240b
uniform_title_display = 240a
uniform_subtitle_display = 240b
marc_display = FullRecordAsXML
marc_text = custom, getAllSearchableFields(100, 900)

title_text = 245a:245b:240a:240b:700t 
title_display = 245a
subtitle_display = 245b 
title_added_entry_display = 700t
call_number_text = custom, getCallNumberCleaned
call_number_display = 999a:090a:050a, first
year_multisort_i = DateOfPublication
isbn_text = 020a
isbn_display = 020a
oclc_text = custom, getOclcNum
        
call_number_facet = custom, getCallNumberPrefix
date_indexed_facet = index_date
source_facet = "Library Catalog"
subject_era_facet = 650d:650y:651y:655y
topic_form_genre_facet = 650a:650b:650x:655a
subject_geographic_facet = 650c:650z:651a:651x:651z:655z
broad_format_facet = 000[6]:007[0], format_maps.properties(broad_format), first
format_facet = 999t, format_maps.properties(format)
language_facet = 008[35-37]:041a:041d, language_map.properties
location_facet = 999k:999l, location_map.properties
library_facet = 999m, library_map.properties
instrument_facet = 048a[0-1], instrument_map.properties
recording_type_facet = 000[6], (map.recording_type)
recordings_and_scores_facet = custom, getRecordingAndScore
recording_format_facet = custom, getRecordingFormat, format_maps.properties(recording_format)
music_catagory_facet = 999a[0-1]:999a[0], music_maps.properties(music_catagory), first
ports_of_call_facet = 650c:650z:651a:651x:651z:655z, semester_at_sea.properties(port_of_call)
guide_book_facet = 651v, (pattern_map.guide_book)
composition_era_facet = era, music_maps.properties(composition_era)
}}}

If any duplicates are found in the index specification file, the last entry that occurs will be used, and previous entries will be silently ignored. Also note that due to how java handles properties files, the order in which the entries occur is unimportant, if there is some reason you need the index fields to be added to the Solr index in a certain order, you will need to customize this program.

The values that are defined for the index field entries consist of 1 to 3 fields separated by commas.  The first field specifies either the MARC field or fields that the index entry should be extracted from or it indicates that the field is a special case.  These special cases are described below:

The simplest case is when a quoted string appears after the equals sign. Everything that appears in the quotes is taken verbatim and added to the Solr index as is. So in the above example, every record added to the Solr index by this program will have a value of {{{“Library Catalog”}}} stored for the index field named {{{source_facet}}}.  This can be useful when data from several different sources is being added to the same Solr index, to allow searchers to narrow their search to data from one or another of the sources.


If the value after the equals sign is {{{FullRecordAsMARC}}}, {{{FullRecordAsXML}}}, {{{date}}}, {{{index_date}}}, or {{{custom}}} the following actions will be taken:

 * *FullRecordAsMARC:* specifies that the entire MARC record should be added in the standard binary form (ISO 2709).

 * *FullRecordAsXML:* specifies that the entire MARC record should be added encoded using the MARCXML standard.

 * *FullRecordAsText:* specifies that the entire MARC record should be translated to a readable format, and stored, (with {{{<br/>}}} tags being inserted in place of newline characters.

 * *date:* extracts the 260 c subfield from the MARC record, and then extracts a four digit year from that subfield.

 * *index_date:* returns a value for the date and time of when the record was indexed.

 * *custom:* specifies that a custom java routine is to be invoked to extract the value for this field. Examples of when custom might be necessary are:  
   # Create an index entry based on the value in field X, but only if a certain value appears in field Y.  
   # Create an index entry that consists of the first characters from a given field, but only as many characters as are letters.  
   # Create an index entry based on a portion of a given field, but only if the remaining portion of that field contains a certain value.   
 Details of how to define a custom indexing routine are explained later in this document.

If the value after the equals sign is not one of these special cases entries, it is assumed to be a list of MARC fields from which to extract the data to use for the index field.

<br />

==== Specifying Which Fields and Subfields to Use ====

The syntax for specifying what fields/subfields (or what portion of a field or subfield) is to be looked-at to create the Solr index field(s) consists of one or more field specifications separated by colons (:).  

A field specification consists of a three-digit string (000 – 999) followed by an optional subfield specification letter (a – z) followed by an optional field segment specification (either a single number enclosed within brackets [0] indicating that only the first letter of the field is to be returned, or two numbers, separated by a dash, enclosed within brackets [35-37] indicating characters 35 through 37 should be returned)

<br />
===== Example Field Specifications =====

 {{{title_display = 245a}}}

This field specification gathers will extract all of the subfield _a_ for all of the 245 fields in the MARC and add a separate index record entry labeled {{{title_display}}}, for each of them.  Although in this case since the MARC record specification states that there can only be a single 245 field and only a single subfield _a_, the results of this specification will be identical to what they would be if the field specification was{{{title_display = 245a, first}}} 

<br />
 {{{author_text = 100a:110a:111a:130a}}}

This field specification gathers all of the entries from the _a_ subfields of the fields 100, 110, 111 and 130.  Each of these entries is added as a separate index record entry for current documents in the Solr search engine.

<br />
 {{{language_facet = 008[35-37]:041a:041d, language_map.properties}}}

This field specification states that characters 35 through 37 should be selected from the 008 control field of the MARC record (which is where a three-letter encoding of the primary language of a bibliographic work is found.) Additionally, all occurrences of the _a_ and _d_ subfields of all 041 fields in the MARC record are added to the set of strings.

Note that you CANNOT specify 041ad in the field specification, each colon separated item can only reference a single field and subfield.  Also note that a second parameter is present on the field specification entry: {{{language_map.properties}}}.  If this optional parameter is present, once the set of strings is created for all of the fields and subfields specified in the first parameter, the entire set is translated using the translation map that is defined in the separate property file named {{{language_map.properties}}}, (which maps the three-letter abbreviations for languages to the full name of that language; Hence "eng" becomes "English," "fre" becomes "French," "chp" becomes "Chipewyan," and "peo" becomes the ever-popular "Old Persian (ca. 600-400 B.C.)."  The details of how to define a translation map is covered in the next section.

<br />
 {{{broad_format_facet = 000[6]:007[0], format_maps.properties(broad_format), first}}}

This field specification states that the value of character 6 (counting from 0) of field 000 (which stands for the leader of the MARC record) and character 0 of field 007 are to be extracted.  Both of these values are to then be translated using the translation map that is defined in the separate property file named {{{format_maps.properties}}}, by loading all the entries there that start with the string {{{broad_format}}}. The first translated value is to be used as the value for the Solr index entry.  

Or to put it more succinctly, look up character 6 of the 000 field in the map {{{broad_format}}}, if the map contains a mapping for that character, use that value; otherwise, look up character 0 of the 007 field in the map {{{broad_format}}}, if the map contains a mapping for that character use that value. If neither extracted value matches an entry in the translation map, check to see whether the map defines a default value, if so use that default value, otherwise leave the {{{broad_format_facet}}} index entry unassigned.
